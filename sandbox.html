<!doctype html>
<html>
    <head>
        <script type="text/javascript">
const audioContext = new AudioContext()

function audioWorkletCode() {
    console.log("AudioWorklet: start")

    const BLOCK_SIZE = 1024

    class DoubleBufferProcessor extends AudioWorkletProcessor {
        constructor(options) {
            console.log("AudioWorklet: constructor")
            super()
            this.currentBuffer = new Float32Array(BLOCK_SIZE)
            this.nextBuffer = new Float32Array(BLOCK_SIZE)
            this.index = 0

            this.port.onmessage = (e) => {
                this.nextBuffer = e.data
                this.nextBufferReady = true
            }

            this.swapBuffers()
        }

        swapBuffers() {
            [this.currentBuffer, this.nextBuffer] = [this.nextBuffer, this.currentBuffer]
            this.index = 0
            this.nextBufferReady = false
            // Send next buffer for the Web Worker to fill.
            this.port.postMessage(this.nextBuffer, [this.nextBuffer.buffer])
        }

        process(inputs, outputs, parameters) {
            const output = outputs[0][0]
            if (this.index >= BLOCK_SIZE) {
                // Currently in underrun.
                console.log("Underrun!")
                output.fill(0)
            } else {
                output.set(this.currentBuffer.subarray(this.index, this.index + output.length))
            }
            // NOTE: This assumes BLOCK_SIZE is a multiple of output.length (128).
            this.index += output.length
            if (this.index >= BLOCK_SIZE && this.nextBufferReady) {
                this.swapBuffers()
            }
            return true
        }
    }

    registerProcessor("doublebuffer", DoubleBufferProcessor)
}

function webWorkerCode() {
    console.log("Web Worker: start")
    let port

    self.onmessage = async (event) => {
        // Receive sample rate and Audio Worklet's port from main thread.
        console.log("Web Worker: setup")
        setup(event.data.sampleRate)
        port = event.data.port
        port.onmessage = (e) => {
            // Received empty buffer from Audio Worklet. Fill with generated samples and send it back.
            // Uncomment to force occasional underruns:
            // for (let j = 0; j < (1 << 25); j++) {}
            const length = process(e.data)
            if (length < e.data.length) {
                // `process` did not fill the buffer, indicating the end of the piece.
                e.data.fill(0, length)
                // Generate silence from here on out.
                port.onmessage = (e) => {
                    e.data.fill(0)
                    port.postMessage(e.data, [e.data.buffer])
                }
            }
            port.postMessage(e.data, [e.data.buffer])
        }
    }

    // --- User (composer) code starts here ---
    let sampleRate
    const freq = 300  // Hz
    const dur = 2.5   // seconds
    let phase, remainingSamples

    function setup(_sampleRate) {
        sampleRate = _sampleRate
        phase = 0
        remainingSamples = Math.floor(dur * sampleRate)
    }

    function process(output) {
        let i
        const n = Math.min(remainingSamples, output.length)
        for (i = 0; i < n; i++) {
            output[i] = Math.sin(phase)
            phase += 2*Math.PI*freq/sampleRate
            phase %= 2*Math.PI
        }
        remainingSamples -= i
        return i
    }
}

function getBody(fn) {
    const s = fn.toString()
    return s.slice(s.indexOf("{") + 1, s.lastIndexOf("}"))
}

const webWorker = new Worker(URL.createObjectURL(
    new Blob([getBody(webWorkerCode)], { type: "application/javascript" })
))

function resumeContextOnInteraction() {
    // from https://github.com/captbaritone/winamp2-js/blob/a5a76f554c369637431fe809d16f3f7e06a21969/js/media/index.js#L8-L27
    if (audioContext.state === "suspended") {
        const resume = async () => {
            await audioContext.resume()
            if (audioContext.state === "running") {
                document.body.removeEventListener("touchend", resume, false)
                document.body.removeEventListener("click", resume, false)
                document.body.removeEventListener("keydown", resume, false)
            }
            setupAudio()
        }
        document.body.addEventListener("touchend", resume, false)
        document.body.addEventListener("click", resume, false)
        document.body.addEventListener("keydown", resume, false)
    } else {
        setupAudio()
    }
}

async function setupAudio() {
    await audioContext.resume()
    console.log("Sample rate:", audioContext.sampleRate)
    await audioContext.audioWorklet.addModule(window.URL.createObjectURL(
        new Blob([getBody(audioWorkletCode)], { type: "application/javascript" })
    ))
    const audioWorklet = new AudioWorkletNode(audioContext, "doublebuffer", {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
    })
    // Send sample rate and Audio Worklet's port to the Web Worker, which will generate the samples as needed.
    webWorker.postMessage({ sampleRate: audioContext.sampleRate, port: audioWorklet.port }, [audioWorklet.port])
    audioWorklet.connect(audioContext.destination)
}
        </script>
    </head>
    <body>
        Hello
        <script type="text/javascript">
resumeContextOnInteraction()
        </script>
    </body>
</html>
